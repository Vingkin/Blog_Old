<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>操作系统中 | Vingkin的学习文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/Blog/vuepress/favicon.ico">
    <script language="javascript" type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/Blog/js/MouseClickEffect.js"></script>
    <meta name="description" content="~~~">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/Blog/assets/css/0.styles.17f0d514.css" as="style"><link rel="preload" href="/Blog/assets/js/app.4417eb82.js" as="script"><link rel="preload" href="/Blog/assets/js/3.2daec6eb.js" as="script"><link rel="preload" href="/Blog/assets/js/1.3441dec7.js" as="script"><link rel="preload" href="/Blog/assets/js/11.385157e5.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.f0f7997f.js"><link rel="prefetch" href="/Blog/assets/js/12.43533bfe.js"><link rel="prefetch" href="/Blog/assets/js/13.fca9ec1a.js"><link rel="prefetch" href="/Blog/assets/js/14.4ef5a506.js"><link rel="prefetch" href="/Blog/assets/js/15.25d1439b.js"><link rel="prefetch" href="/Blog/assets/js/16.e4200779.js"><link rel="prefetch" href="/Blog/assets/js/17.0f620a4b.js"><link rel="prefetch" href="/Blog/assets/js/18.3e2c61c2.js"><link rel="prefetch" href="/Blog/assets/js/19.c841fda6.js"><link rel="prefetch" href="/Blog/assets/js/20.7e7aa66c.js"><link rel="prefetch" href="/Blog/assets/js/21.c4003560.js"><link rel="prefetch" href="/Blog/assets/js/22.0406d90f.js"><link rel="prefetch" href="/Blog/assets/js/23.71a12a58.js"><link rel="prefetch" href="/Blog/assets/js/24.dae641fb.js"><link rel="prefetch" href="/Blog/assets/js/25.219b65bd.js"><link rel="prefetch" href="/Blog/assets/js/26.4e8222ba.js"><link rel="prefetch" href="/Blog/assets/js/27.09e9f908.js"><link rel="prefetch" href="/Blog/assets/js/28.c3952bad.js"><link rel="prefetch" href="/Blog/assets/js/29.6f972569.js"><link rel="prefetch" href="/Blog/assets/js/30.c34fffbe.js"><link rel="prefetch" href="/Blog/assets/js/31.c79fd8b8.js"><link rel="prefetch" href="/Blog/assets/js/32.e8d64e7e.js"><link rel="prefetch" href="/Blog/assets/js/33.d1b0b891.js"><link rel="prefetch" href="/Blog/assets/js/34.1f6ad2c0.js"><link rel="prefetch" href="/Blog/assets/js/35.1fac3064.js"><link rel="prefetch" href="/Blog/assets/js/36.80d4f061.js"><link rel="prefetch" href="/Blog/assets/js/37.7aa2ac27.js"><link rel="prefetch" href="/Blog/assets/js/38.2e6db6ef.js"><link rel="prefetch" href="/Blog/assets/js/39.c694788f.js"><link rel="prefetch" href="/Blog/assets/js/4.75bd0991.js"><link rel="prefetch" href="/Blog/assets/js/40.f46a350c.js"><link rel="prefetch" href="/Blog/assets/js/41.31e6560f.js"><link rel="prefetch" href="/Blog/assets/js/42.97d443e9.js"><link rel="prefetch" href="/Blog/assets/js/43.bd75055b.js"><link rel="prefetch" href="/Blog/assets/js/44.155af8d3.js"><link rel="prefetch" href="/Blog/assets/js/45.a371798f.js"><link rel="prefetch" href="/Blog/assets/js/46.01c1199d.js"><link rel="prefetch" href="/Blog/assets/js/47.d4a385db.js"><link rel="prefetch" href="/Blog/assets/js/48.0ebb7ce7.js"><link rel="prefetch" href="/Blog/assets/js/49.b1cab958.js"><link rel="prefetch" href="/Blog/assets/js/5.fb11ee35.js"><link rel="prefetch" href="/Blog/assets/js/50.6b058eb4.js"><link rel="prefetch" href="/Blog/assets/js/51.a5d807a2.js"><link rel="prefetch" href="/Blog/assets/js/52.3054df5d.js"><link rel="prefetch" href="/Blog/assets/js/53.7470179e.js"><link rel="prefetch" href="/Blog/assets/js/54.7f3159e8.js"><link rel="prefetch" href="/Blog/assets/js/55.5e8ba284.js"><link rel="prefetch" href="/Blog/assets/js/56.acb1d7cf.js"><link rel="prefetch" href="/Blog/assets/js/57.a115610c.js"><link rel="prefetch" href="/Blog/assets/js/58.a97752ca.js"><link rel="prefetch" href="/Blog/assets/js/59.0ffd11b8.js"><link rel="prefetch" href="/Blog/assets/js/6.623615b6.js"><link rel="prefetch" href="/Blog/assets/js/60.e7dc7070.js"><link rel="prefetch" href="/Blog/assets/js/61.e63abaa0.js"><link rel="prefetch" href="/Blog/assets/js/62.d32de587.js"><link rel="prefetch" href="/Blog/assets/js/63.2f3f0652.js"><link rel="prefetch" href="/Blog/assets/js/64.4f989fd3.js"><link rel="prefetch" href="/Blog/assets/js/65.e358d834.js"><link rel="prefetch" href="/Blog/assets/js/66.026d73ea.js"><link rel="prefetch" href="/Blog/assets/js/67.576ada3a.js"><link rel="prefetch" href="/Blog/assets/js/68.9f8f16af.js"><link rel="prefetch" href="/Blog/assets/js/69.07b64bdb.js"><link rel="prefetch" href="/Blog/assets/js/7.9749877c.js"><link rel="prefetch" href="/Blog/assets/js/70.2ee86b48.js"><link rel="prefetch" href="/Blog/assets/js/8.5d1f39fa.js"><link rel="prefetch" href="/Blog/assets/js/9.84e28c7d.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.17f0d514.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>Vingkin的学习文档</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>~~~</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>Vingkin</span>
            
          <!---->
          2023
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><img src="/Blog/logo.gif" alt="Vingkin的学习文档" class="logo"> <span class="site-name">Vingkin的学习文档</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link"><i class="undefined"></i>
  Home
</a></div><div class="nav-item"><a href="/Blog/guide/interview/Java.html" class="nav-link"><i class="undefined"></i>
  Java相关
</a></div><div class="nav-item"><a href="/Blog/OS/OS1.html" class="nav-link"><i class="undefined"></i>
  操作系统
</a></div><div class="nav-item"><a href="/Blog/netty/nio/three_component.html" class="nav-link"><i class="undefined"></i>
  Netty
</a></div><div class="nav-item"><a href="/Blog/designmode/SoftwareDesignPrinciples.html" class="nav-link"><i class="undefined"></i>
  设计模式
</a></div><div class="nav-item"><a href="/Blog/ml/YOLOv3.html" class="nav-link"><i class="undefined"></i>
  机器学习
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微服务
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/microservice/reactive/reactivestream.html" class="nav-link"><i class="undefined"></i>
  响应式编程
</a></li><li class="dropdown-item"><!----> <a href="/Blog/microservice/middleware/elasticsearch/ElasticSearchBase.html" class="nav-link"><i class="undefined"></i>
  中间件
</a></li></ul></div></div> <a href="https://github.com/vingkin/Blog" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <h3 class="name" data-v-39576ba9>
    Vingkin
  </h3> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>60</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link"><i class="undefined"></i>
  Home
</a></div><div class="nav-item"><a href="/Blog/guide/interview/Java.html" class="nav-link"><i class="undefined"></i>
  Java相关
</a></div><div class="nav-item"><a href="/Blog/OS/OS1.html" class="nav-link"><i class="undefined"></i>
  操作系统
</a></div><div class="nav-item"><a href="/Blog/netty/nio/three_component.html" class="nav-link"><i class="undefined"></i>
  Netty
</a></div><div class="nav-item"><a href="/Blog/designmode/SoftwareDesignPrinciples.html" class="nav-link"><i class="undefined"></i>
  设计模式
</a></div><div class="nav-item"><a href="/Blog/ml/YOLOv3.html" class="nav-link"><i class="undefined"></i>
  机器学习
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微服务
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/microservice/reactive/reactivestream.html" class="nav-link"><i class="undefined"></i>
  响应式编程
</a></li><li class="dropdown-item"><!----> <a href="/Blog/microservice/middleware/elasticsearch/ElasticSearchBase.html" class="nav-link"><i class="undefined"></i>
  中间件
</a></li></ul></div></div> <a href="https://github.com/vingkin/Blog" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <ul class="sidebar-links"><li><a href="/Blog/OS/OS1.html" class="sidebar-link">操作系统上</a></li><li><a href="/Blog/OS/OS2.html" aria-current="page" class="active sidebar-link">操作系统中</a></li><li><a href="/Blog/OS/OS3.html" class="sidebar-link">操作系统下</a></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>操作系统中</h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>Vingkin</span>
            
          <!---->
          2023
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">操作系统中</h1> <div data-v-f875f3fc><i class="iconfont reco-account" data-v-f875f3fc><span data-v-f875f3fc>keyhx</span></i> <i class="iconfont reco-date" data-v-f875f3fc><span data-v-f875f3fc>2022-6-28</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="_1、死锁的概念"><a href="#_1、死锁的概念" class="header-anchor">#</a> 1、死锁的概念</h2> <ol><li><p>什么是死锁</p> <ul><li>在并发环境下，<strong>各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong></li> <li><strong>发生死锁至少有两个或两个以上的进程同时发生死锁</strong>，发生死锁后，若无外力干涉，这些进程都无法向前推进，发生死锁的进程一定是在阻塞态</li> <li>饥饿的概念：
<ul><li><strong>由于长期得不到想要的资源，某进程无法向前推进的现象</strong>，比如SPF如果有源源不断的短进程到来，则长进程一直无法获得处理机</li></ul></li> <li>死循环的概念
<ul><li><strong>某进程在执行的过程中一直跳不出某个循环的现象</strong>，有时是因为程序bug导致的，有时是程序员故意为之</li></ul></li> <li>死锁、饥饿、死循环的异同
<ul><li>异如上</li> <li>同：都是进程无法顺利向前推进的现象(故意设计的死循环除外)</li></ul></li></ul> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/90.jpg" alt=""></p></li> <li><p>死锁产生的条件</p> <ul><li><p>1、<strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁</p></li> <li><p>2、<strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</p></li> <li><p>3、<strong>请求和保持条件</strong>：进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</p></li> <li><p>4、<strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</p></li> <li><p>注意：发生死锁的时候一定有循环等待，但是发生循环等待的时候未必死锁，因为如果同类资源的数量大于1，当该类资源又进程释放的时候，死锁结束。如果每类资源只有1个，那就是充分必要条件了</p></li></ul></li> <li><p>什么时候会发生死锁</p> <ul><li>1、<strong>对系统资源的竞争</strong>。对不可剥夺资源的竞争可能会引起死锁，对可剥夺的资源不会产生</li> <li>2、<strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，比如，并发执行的进程P1、P2分别申请并占有了资源R1,R2,但是之后P1进程又申请资源R2，P2进程申请资源R1，这样会导致死锁</li> <li>3、<strong>信号量的使用不当</strong>。比如，实现互斥的P操作在实现同步的P操作之前</li></ul></li> <li><p>死锁的处理策略</p> <ul><li>1、<strong>预防死锁</strong>：破坏死锁产生的四个必要条件中的一个或几个</li> <li>2、<strong>避免死锁</strong>：用某种方法阻止系统进入不安全的状态</li> <li>3、<strong>死锁的检测和解除</strong>：允许死锁的产生，不过操作系统会负责检测出死锁的产生，然后采取某种措施解除死锁</li></ul></li></ol> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C7.jpg" alt=""></p> <h2 id="_2、死锁的处理策略-预防死锁"><a href="#_2、死锁的处理策略-预防死锁" class="header-anchor">#</a> 2、死锁的处理策略----预防死锁</h2> <ol><li><p>破坏互斥条件</p> <ul><li><p>把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如使用SPOOLing技术。</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/91.jpg" alt=""></p></li> <li><p>缺点：并不是所有的资源都可以改造成可共享使用资源，并且为了系统安全，在很多地方还必须保护这种互斥性，无法破坏</p></li></ul></li> <li><p>破坏不剥夺条件</p> <ul><li>方案一：当某个进程请求的资源得不到满足的时候，它必须立即释放保持的所有资源，待以后需要的时候再重新申请一下</li> <li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺，这种方式需要考虑进程的优先级</li> <li>缺点：
<ul><li>1、实现起来比较复杂</li> <li>2、释放已经获得的资源可能造成前一阶段工作的失效，因此一般只适用于易保存和恢复状态的资源，如CPU</li> <li>3、反复的申请和释放资源会增加系统的开销，降低系统吞吐量</li> <li>4、如果采用方案一，如果一直重复这样会导致饥饿</li></ul></li></ul></li> <li><p>破坏请求和保持条件</p> <ul><li>采用静态分配方法：进程在运行前一次申请完它所需要的全部资源</li> <li>缺点：会造成严重的资源浪费，资源利用率低，也有可能导致饥饿(比如有三个进程A,B,C，其中A，B分别使用资源1,2，进程C需要用到A资源1和2，如果有源源不断的进程使用1或者2，则C一直不执行 )</li></ul></li> <li><p>破坏循环等待条件</p> <ul><li>采用顺序资源分配法：首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，编号相同资源一次申请完</li> <li>原理分析：一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源，不可以大编号资源的进程逆向申请小编号的资源，这样就不会产生循环等待</li> <li>缺点：
<ul><li>1、不方便增加新设备，因为可能需要重新分配所有的编号</li> <li>2、进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li> <li>3、必须按规定次序申请资源，用户编程麻烦</li></ul></li></ul></li></ol> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C8.jpg" alt=""></p> <h2 id="_3、死锁的处理策略-避免死锁"><a href="#_3、死锁的处理策略-避免死锁" class="header-anchor">#</a> 3、死锁的处理策略----避免死锁</h2> <ol><li>什么是安全序列
<ul><li>所谓<strong>安全序列，就是指系统按照这种序列分配资源，则每个进程都能顺利完成</strong>。只要能找到一个安全序列，系统就是<strong>安全状态</strong>。当然<strong>安全序列可能有多个</strong></li> <li>如果分配资源后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>，这就意味着之后可能所有进程都无法顺利执行下去。如果有进程提前归还了一些资源，系统还是有可能重新回到安全状态</li> <li>如果系统处于安全状态，就一定不会发生死锁，如果系统进入不安全状态，就<strong>可能</strong>发生死锁(处于不安全状态未必发生了死锁，但发生死锁的时候就一定是处于不安全状态)</li> <li>可以<strong>在资源分配之前预先判断这次分配会不会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求，这是<strong>银行家算法</strong>核心思想</li></ul></li></ol> <h2 id="_4、死锁的处理策略-检测和解除"><a href="#_4、死锁的处理策略-检测和解除" class="header-anchor">#</a> 4、死锁的处理策略----检测和解除</h2> <ol><li><p>为了能对系统死锁进行检测需要满足的条件</p> <ul><li><p>1、用某种数据结构来保存资源的请求和分配信息</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/92.jpg" alt=""></p></li> <li><p>上图中绿色表示已经分配的资源，蓝色表示正在请求的资源。按照上述过程，最终能够消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁。比如P2中申请一个R1，但是此时R1已经分配出去三个了，所以P2进入阻塞的状态，要等P1释放资源</p></li></ul></li> <li><p>解除死锁</p> <p>用死锁检测算法化简资源分配图之后，还连着的边的那些进程就是死锁进程，解除死锁的主要方法：</p> <ul><li>1、<strong>资源剥夺法</strong>：挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程</li> <li>2、<strong>撤销进程法(或终止进程法)</strong>：强制撤销部分、甚至全部死锁的进程，并剥夺这些进程的资源，这种方式的优点是实现简单，但代价有点大，撤销进程之前的运行都芜湖了</li> <li>3、<strong>进程回退法</strong>：让一个或多个死锁进程回退到避免死锁的地步。这要求系统记录进程的历史信息，设置还原点</li></ul> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C9.jpg" alt=""></p></li></ol> <h2 id="_5、内存的基础知识"><a href="#_5、内存的基础知识" class="header-anchor">#</a> 5、内存的基础知识</h2> <ol><li><p>什么是内存？有何作用？</p> <ul><li>内存是用于存放数据的硬件。<strong>程序执行前需要先放到内存中才能被CPU处理</strong></li> <li>如何区分各个程序的数据在内存的什么地方？
<ul><li>给内存的存储单元编地址
<ul><li>内存地址从0开始，每个单元对应一个存储单元(相当于宾馆的房间)</li> <li>如果计算机<strong>按字节编址</strong>，则每个<strong>存储单元大小为1字节</strong>，即1B，即8个二进制位</li> <li>如果<strong>字长为16位</strong>的计算机<strong>按字编址</strong>，则每个<strong>存储单元大小为1个字</strong>，<strong>每个字的大小为16个二进制位</strong>(取决于计算机的字长)</li></ul></li></ul></li></ul></li> <li><p>几个常用的数量单位</p> <ul><li>2^10 =  1K      (千)</li> <li>2^20 =  1M      (兆，百万)</li> <li>2^30 =  1G      (亿，千兆)</li> <li>一台手机有4GB内存，是什么意思？
<ul><li>指该手机内存可以存放4 * 2^30 个字节，如果按照字节编址的话，也就是有4 * 2^30 = 2^32 个存储单元(个房间)</li> <li>需要 2^32个地址才能一一标识，也就是地址需要用32个二进制位来表示</li></ul></li></ul></li> <li><p>进程的运行原理 --- 指令</p> <ul><li>我们写的代码最终被翻译成CPU能够识别的指令，这些指令会告诉CPU去内存的哪个地址存/取数据，这个数据应该做什么样的处理。在编译生成的指令中一般使用的是逻辑地址(相对地址)</li> <li>逻辑地址(相对地址) VS 物理地址(绝对地址)
<ul><li>逻辑地址就是相对初始位置的距离，在内存中<strong>实际存放的位置 = 起始位置 + 逻辑地址</strong></li> <li>物理地址即绝对地址，就是数据存放在内存中的实际位置</li></ul></li></ul></li> <li><p>从写程序到程序运行</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/93.jpg" alt=""></p> <ul><li><p>装入的三种方式(逻辑地址 -&gt; 物理地址的转换)</p> <ul><li><p>1、<strong>绝对装入</strong>：在编译的时候就知道程序存放在内存的哪个位置，编译程序产生绝对地址的目标代码(目标模块中的指令就是内存中的绝对地址)，装入程序按照装入模块中的地址，将程序和数据装入内存。</p> <p><strong>绝对装入只适用于单道程序的环境</strong>(因为地址已经写死，如果多道程序的话会冲突)。程序中使用的绝对地址，可以在编译或者汇编的时候给出，也可由程序员直接赋予，但通常都是编译或汇编时在转换为绝对地址</p></li> <li><p>2、<strong>静态重定位</strong>：又称<strong>可重定位装入</strong>，编译和链接之后指令中的地址都是从0开始的逻辑地址，根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行重定位</strong>，<strong>将逻辑地址变换为物理地址</strong>(地址变换是在装入的时候一次性完成的)</p> <p>特点：一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存空间，就不能装入该作业，作业一旦进入内存之后，在运行期间不能再移动，也不能再申请内存空间</p></li> <li><p>3、<strong>动态重定位</strong>(现在使用)：又称为<strong>动态运行时装入</strong>。编译和链接之后装入模块的地址都是从0开始，<strong>装入程序将装入模块装入到内存之后也不会立即将逻辑地址变换为物理地址，而是把地址转换推迟到程序真正要执行时才进行</strong>。因此装入到内存中的地址依旧是逻辑地址，这种方式需要一个<strong>重定位寄存器</strong>(存放起始地址)的支持</p> <p>特点：动态重定位时<strong>允许程序在内存中发生移动</strong>，并且可将程序分配到不连续的存储区，在程序运行前只需要装入它的部分代码就可以运行，在程序运行期间，可以动态申请内存分配</p></li></ul></li> <li><p>链接的三种方式</p> <ul><li>1、<strong>静态链接</strong>：在程序运行之前，将各个目标模块连接到装入模块</li> <li>2、<strong>装入时动态链接</strong>：将各个目标模块装入内存时，边装入边链接</li> <li>3、<strong>运行时动态链接</strong>：在程序执行中需要改目标模块时，才对他进行连接</li></ul></li></ul> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C10.jpg" alt=""></p></li></ol> <h2 id="_6、内存管理的概念"><a href="#_6、内存管理的概念" class="header-anchor">#</a> 6、内存管理的概念</h2> <ol><li>操作系统负责<strong>内存空间的分配和回收</strong></li> <li>操作系统需要提供某种技术<strong>从逻辑上对内存空间进程扩充</strong>-----覆盖技术、交换技术、虚拟存储技术</li> <li>操作系统需要提供地址转换功能，<strong>负责程序的逻辑地址与物理地址的转换</strong>----三种装入方式</li> <li>操作系统需要提供<strong>内存保护</strong>功能，保证各进程在各自存储空间内运行互不干扰
<ul><li>方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址的时候，CPU检查是否越界</li> <li>方法二：采用**重定位寄存器(又称为基址寄存器)和界地址寄存器(又称限长寄存器)**进行越界检查。</li></ul></li></ol> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C11.jpg" alt=""></p> <h2 id="_7、内存空间的扩充-覆盖与交换"><a href="#_7、内存空间的扩充-覆盖与交换" class="header-anchor">#</a> 7、内存空间的扩充-----覆盖与交换</h2> <ol><li><p>覆盖技术：用来解决程序大小超过物理内存总和的问题</p> <ul><li>思想：将<strong>程序分为多个段</strong>(多个模块)。<strong>常用的段常驻内存，不常用的段在需要时调入内存</strong></li> <li>内存中分为一个<strong>固定区</strong>和若干个<strong>覆盖区</strong></li> <li>需要常驻内存的段放入固定区，调入后就不再调出(除非运行结束)</li> <li>不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存</li></ul> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/94.jpg" alt=""></p> <ul><li>特点：必须由程序员声明覆盖结构，操作系统完成自动覆盖，缺点：对用户不透明，增加了用户编程的负担，现在不使用了</li></ul></li> <li><p>交换技术</p> <ul><li>设计思想：内存空间紧张的时候，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。就是将某些进程挂起。中级调度：就是决定将哪个处于挂起状态的进程重新调入内存。(PCB会常驻内存，不会被换出内存)</li> <li>应该在外存(磁盘)的什么位置保存被换出的进程？
<ul><li>具有对换功能的操作系统中，通常将磁盘空间分为<strong>文件区和对换区</strong>两部分。<strong>文件区</strong>主要存放文件，主要<strong>追求存储空间的利用率</strong>，因此文件区空间的管理采用<strong>离散分配方式</strong>；对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>，因为需要对换的速度，所以对换区空间的管理主要<strong>追求换入换出速度</strong>，通常<strong>采用连续分配方式</strong>。总之<strong>对换区的I/O速度比文件区的更快</strong></li></ul></li> <li>什么时候应该交换？
<ul><li>交换通常发生在许多进程运行且<strong>内存吃紧时</strong>进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程，如果缺页率明显下降，就可以暂停换出</li></ul></li> <li>应该换出哪些进程？
<ul><li><strong>可优先换出阻塞进程；可换出低优先级的进程</strong>；为了防止低优先级进程发生饥饿，有的系统还会考虑进程在内存中的驻留时间</li></ul></li></ul> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C12.jpg" alt=""></p></li></ol> <h2 id="_8、内存空间的分配-连续分配管理方式"><a href="#_8、内存空间的分配-连续分配管理方式" class="header-anchor">#</a> 8、内存空间的分配-----连续分配管理方式</h2> <ol><li><p>连续分配：就是为用户进程分配的必须是一个连续的内存空间</p></li> <li><p><strong>单一连续分配方式</strong></p> <ul><li>内存被分为<strong>系统区和用户区</strong>，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据，用户区用于存放用户进程的相关数据</li> <li>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间</li> <li>特点：
<ul><li>优点：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护</li> <li>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>(分配给某进程的内存区域中，如果有些部分没有用上，就是内部碎片)；存储器利用率极低</li></ul></li></ul> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/13.jpg" alt=""></p></li> <li><p><strong>固定分区分配</strong></p> <ul><li><p><strong>将用户空间划分为若干个固定大小的分区</strong>，<strong>在每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的多道程序的内存管理方式。</p></li> <li><p>固定分区分配分为两种：</p> <ul><li>分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合</li> <li>分区大小不等：增加了灵活性，可以满足不同大小的进程的需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)</li></ul></li> <li><p>操作系统如何记录各个分区空闲或者分配的情况？</p> <ul><li>操作系统需要建立一个数据结构---<strong>分区说明表</strong>，来实现各个分区的分配和回收。每个表项对应一个分区，<strong>包括分区号、对应分区的大小、起始地址、状态(是否已分配)</strong></li> <li>当用户进程要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个满足条件的分区，然后修改分区状态</li></ul></li> <li><p>特点：</p> <ul><li>优点：实现简单；<strong>无外部碎片</strong></li> <li>缺点：
<ul><li>1、当用户程序太大时，可能所有的分区都不能满足，此时不得不采取覆盖技术来解决，但是这回降低系统性能</li> <li>2、<strong>会产生内部碎片</strong>，内存利用率低</li></ul></li></ul> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C14.jpg" alt=""></p></li></ul></li> <li><p><strong>动态分区分配(可变分区分配)</strong></p> <ul><li><p>原理：在线程装入内存时，<strong>根据进程的大小动态建立分区</strong>，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的</p></li> <li><p>系统要用什么样的数据结构记录内存的使用情况？</p> <ul><li>空闲分区表：每个空闲分区对应一个表项。表项中包含分区、分区信息、分区起始地址、状态等信息</li> <li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。</li></ul> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C15.jpg" alt=""></p></li> <li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p> <ul><li>按照动态分区分配算法</li></ul></li> <li><p>如何进行分区的分配和回收操作？</p> <ul><li>如何进行分配：假设采用的数据结构是空闲分区表，则修改对应分区号，以及剩余的分区大小和起始地址等信息</li> <li>如何进行回收：
<ul><li>情况一：回收区的前或后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个</li> <li>情况二：回收区的前、后各有一个相邻的空闲分区，需要将一整块的空闲分区合并</li> <li>情况三：回收区的前、后都没有相邻的空闲分区，需要新增一个空闲分区</li></ul></li></ul></li> <li><p>注意：各表项的顺序不一定按照地址递增的顺序排序，具体的排序方式需要依据动态分配算法来确定</p></li> <li><p>特点：没有内部碎片，但是有外部碎片</p> <ul><li>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上</li> <li>外部碎片：内存中的某些空闲分区由于太小难以利用</li> <li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于该进程需要连续的内存空间，因此这些碎片不能满足进程的需求，可以通过紧凑(拼凑) 的技术来解决(把已占的内存挪位)</li></ul></li></ul></li></ol> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5CDD%5C16.jpg" alt=""></p> <h2 id="_9、动态分区分配算法"><a href="#_9、动态分区分配算法" class="header-anchor">#</a> 9、动态分区分配算法</h2> <ol><li><p>首次适应算法</p> <ul><li>算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区</li> <li>实现：**空闲分区以地址递增的次序排列。**每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。</li> <li>缺点：导致低地址出现很多小的难以利用的空闲区</li></ul></li> <li><p>最佳适应算法(先用小的)</p> <ul><li>算法思想：优先使用更小的空闲区，尽可能更多的留下大片的空闲区</li> <li>实现：空闲分区<strong>按照容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。</li> <li>缺点：每次都选最小的分区，会留下越来越多的又小又难利用的内存块，会产生很多的外部碎片</li></ul></li> <li><p>最坏适应算法(先用大的)</p> <ul><li>算法思想：优先使用最大的连续空闲区，这样留下的空闲区就不会太小，更方便使用</li> <li>实现：<strong>空闲分区按照容量递减的次序链接</strong>。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。</li> <li>缺点：每次都选最大的分区，会导致大的空闲区迅速被用完，如果还有大进程到来，就没有内存分区可以用了</li></ul></li> <li><p>邻近适应算法</p> <ul><li>算法思想：每次查找从上次使用地址的下一个开始</li> <li>实现：空闲分区以地址递增的次序排列(第一次排，后面不需要再排)，<strong>每次分配内存时从上次查找结束的位置开始查找空闲分区</strong>，找到大小能够满足要求的第一个空闲分区</li> <li>缺点：每个空闲分区都用相同的概率被使用，也就导致高地址的大分区更可能被使用。划分为小分区，最后也就导致无大分区可用</li></ul> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220508143045462.png" alt="image-20220508143045462"></p></li></ol> <h2 id="_10、基本分页存储管理的基本概念"><a href="#_10、基本分页存储管理的基本概念" class="header-anchor">#</a> 10、基本分页存储管理的基本概念</h2> <p>内存空间非连续分配管理方式</p> <ol><li>基本分页存储管理的思想：<strong>把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分</strong></li> <li>内存拆分为一个个大小相等的分区,每个分区就是一个<strong>页框</strong>(或称为<strong>页帧</strong>)。每个页框有一个编号，就是<strong>页框号</strong>，页框号从0开始</li> <li>进程根据页框大小拆分为一个个区域，称为<strong>页</strong>(或<strong>页面</strong>)。每个页面也有一个编号，即<strong>页号</strong>，页号也是从0开始(进程的最后一个页面可能没有一个页框那么大，页框不能太大，否则<strong>会产生过大的内部碎片</strong>)</li> <li><strong>页面与页框有一一对应关系，页面不必连续存放</strong>，可以放到不相邻的页框中</li> <li>逻辑地址如何转换为物理地址
<ul><li>1、算出逻辑地址对应的页号：页号 = 逻辑地址 / 页面长度</li> <li>2、页号在内存中的起始地址：操作系统用某种数据结构记录</li> <li>3、逻辑地址在页面的偏移量：页内偏移量 = 逻辑地址 % 页面长度</li> <li>4、物理地址= 起始地址 + 偏移量</li></ul></li> <li>结论：如果每个页面大小是2^k,用二进制表示逻辑地址，则末尾K位标识<strong>页内偏移量</strong>，其余部分就是页号</li> <li><strong>页表</strong>：为了能够知道<strong>进程的每一个页面在内存中的存放位置</strong> <ul><li>1、一个进程对应一个页表</li> <li>2、页表由页号和块号(页框号)组成</li></ul></li> <li>页表项：页表中的一条记录</li></ol> <h2 id="_11、基地址变换机构"><a href="#_11、基地址变换机构" class="header-anchor">#</a> 11、基地址变换机构</h2> <ol><li><p>基地址变换机构可以<strong>借助页表将逻辑地址变换为物理地址</strong></p></li> <li><p>系统中设置一个<strong>页表寄存器</strong>，存放<strong>页表的起始地址(页表的开始地址)<strong>和</strong>页表长度(页表项的个数)</strong>，进程未执行时，页表起始地址和长度放在PCB在，当进程被调度时，才会放入页表寄存器</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/08589340b276ee29a357f080ed4012b.jpg" alt="08589340b276ee29a357f080ed4012b"></p></li> <li><p>快表(联想寄存器)：访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项。</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/541a75aa1efce984b24df67aea29aa4.jpg" alt="541a75aa1efce984b24df67aea29aa4"></p></li></ol> <h2 id="_12、两级页表"><a href="#_12、两级页表" class="header-anchor">#</a> 12、两级页表</h2> <ol><li><p>单级页表的问题</p> <ul><li>页表必须连续存放，当页表很大的时候，需要占用很多个连续的页框</li> <li>没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面(后面讲解)</li></ul></li> <li><p>两级页表的原理---- 解决上面第一个问题</p> <ul><li><p>为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>，或称<strong>外层页表</strong>，或称<strong>顶级页表</strong>(套娃)</p></li> <li><p>将页表继续根据页框大小进行拆分</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/f7cd987ba102ecf12110ee6a4416034.jpg" alt="f7cd987ba102ecf12110ee6a4416034"></p></li> <li><p>根据拆分的很多个页表建立页目录表</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/3361d94ab3623353f7997137296d8eb.jpg" alt="3361d94ab3623353f7997137296d8eb"></p></li> <li><p>案例</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/484c54717461b527d7e199d942448f1.jpg" alt="484c54717461b527d7e199d942448f1"></p></li> <li><p>注意：</p> <ul><li>各级页表的大小不能超过一个面</li> <li>两级页表访问内存的次数
<ul><li>1、第一次：访问页目录表</li> <li>2、第二次：访问二级页表</li> <li>3、第三次：访问目标单元</li></ul></li></ul></li></ul> <p>小结：</p> <img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/363577b7f1c121bc7f3e3c31a62d0d3.jpg" alt="363577b7f1c121bc7f3e3c31a62d0d3" style="zoom:150%;"></li></ol> <h2 id="_13、基本分段存储管理方式"><a href="#_13、基本分段存储管理方式" class="header-anchor">#</a> 13、基本分段存储管理方式</h2> <p>与分页的最大区别：离散分配时所分配地址空间的基本单位不同</p> <ol><li><p>分段：程序按照<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>，每个段都有一个段名，每段从0开始编程</p></li> <li><p>内存分配规则：**以段为单位进行分配，每个段在内存中占据连续空间，**但各段之间可以不相邻</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/f6fbed833a9af8b9e4df67b0c17c3fc.jpg" alt="f6fbed833a9af8b9e4df67b0c17c3fc"></p></li> <li><p>分段系统的逻辑地址结构由**段号(段名)<strong>和</strong>段内地址(段内偏移量)**所组成</p> <p><strong>段号的位数决定了每个进程最多可以分几个段</strong></p> <p><strong>段内地址位数决定了每个段的最大长度是多少</strong></p></li> <li><p>段表：能够从物理内存中找到各个逻辑段的存放位置</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/31fd5ca9ccd980db93b6088ea0e1d58.jpg" alt="31fd5ca9ccd980db93b6088ea0e1d58"></p> <ul><li>每个段对应一个段表项，其中记录了该段在内存中的<strong>起始位置(基址)和段的长度</strong></li> <li><strong>各个段表项的长度是相同的</strong>，段号是可以隐含的，不占存储空间</li></ul></li> <li><p>段表寄存器：在PCB中存放段表始址和段表长度</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/19fda1f5ff23a13b9e546eba14effc6.jpg" alt="19fda1f5ff23a13b9e546eba14effc6"></p></li> <li><p>分页与分段的区别</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/3dd975466ed41bb250ad2f71beec3fb.jpg" alt="3dd975466ed41bb250ad2f71beec3fb"></p></li> <li><p>分段比分页相比更容易实现信息的共享和保护</p> <ul><li>实现共享：只需要让各个进程的段表项执行同一个段即可实现共享。不能被修改的代码称为<strong>纯代码或可重入代码</strong>，这样的代码可实现共享。可修改的代码不能实现共享(比如：有一个代码段中有很多变量，各进程并发同时访问可能造成数据不一致)。</li> <li>实现保护与实现共享的原因相似：允许访问的部分应该隔离出来可以访问</li></ul></li></ol> <p>小结：<img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/e8349b3aae72a55aed8e27fdd816b34.jpg" alt="e8349b3aae72a55aed8e27fdd816b34"></p> <h2 id="_14、段页式管理方式"><a href="#_14、段页式管理方式" class="header-anchor">#</a> 14、段页式管理方式</h2> <ol><li><p>分页和分段的优缺点</p> <table><thead><tr><th></th> <th>优点</th> <th>缺点</th></tr></thead> <tbody><tr><td>分页管理</td> <td>内存空间利用率高，<strong>不会产生外部碎片</strong>，只会产生少量的页内碎片</td> <td>不方便实现信息的共享和保护</td></tr> <tr><td>分段管理</td> <td>很方便实现信息的共享和保护</td> <td>如果段过大，为其分配很大的连续空间会很不方便，会产生外部碎片(产生原因与动态分区分配相似)</td></tr></tbody></table></li> <li><p>段页式管理 = 分段 + 分页</p> <p>将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相同的页框，进程前将各页面装入各内存块中</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/9b68045565ab516f5f3e723c7b11f0c.png" alt="9b68045565ab516f5f3e723c7b11f0c"></p> <p>段页式系统的逻辑地址结构由段号、页号、页内地址组成</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220513152328116.png" alt="image-20220513152328116"></p> <p>分段对用户是可见的，程序员编程时需要显示的给出段号、段内地址。而将各段分页是对用户不可见的。系统会根据段内地址自动划分页号和页内偏移地址</p></li> <li><p>段表、页表</p> <p>每个段对应一个段表项，每个段表项由段号、<strong>页表长度、页表存放块号(页表的起始地址)<strong>组成。每个</strong>段表项的长度相等，段号是隐含的</strong></p> <p>每个页面对应一个页表项，每个页表项由页号、<strong>页面存放的内存块号</strong>组成。每个页表项长度相等，页号是隐含。</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220513153925493.png" alt="image-20220513153925493"></p></li> <li><p>逻辑地址转物理地址</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220513154609606.png" alt="image-20220513154609606"></p> <p>也可以引入快表机构</p></li></ol> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220513193835377.png" alt="image-20220513193835377"></p> <h2 id="_15、虚拟内存的概念"><a href="#_15、虚拟内存的概念" class="header-anchor">#</a> 15、虚拟内存的概念</h2> <p>也是为了进行内存空间的扩充</p> <ol><li><p>传统存储管理方式的问题</p> <ul><li>作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong></li> <li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong></li> <li><strong>一旦作业被装入内存，就会一直驻留在内存中</strong>，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源</li></ul></li> <li><p>局部性原理</p> <ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久后该数据很可能再次被访问(因为程序中存在着大量的循环)</li> <li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序的在内存中存放)</li></ul></li> <li><p>高速缓冲技术</p> <p>将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中</p></li> <li><p>虚拟内存</p> <ul><li>在程序装入时，可以<strong>将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行。</li> <li>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由<strong>操作系统负责将所需信息从外存调入内存</strong>，然后继续执行</li> <li>若内存空间不够，由<strong>操作系统负责将内存中暂时用不到的信息换出到外存</strong></li></ul> <p>虚拟内存实际的物理内存大小没有变，只是在逻辑上进行了扩充</p></li> <li><p>虚拟内存的三个主要特征</p> <ul><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是被允许分成多次调入内存</li> <li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li> <li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul></li> <li><p>如何实现虚拟内存技术</p> <p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配的方式，会不方便实现。因此，虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式的基础上</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220515155525114.png" alt="image-20220515155525114"></p></li></ol> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220515155622275.png" alt="image-20220515155622275"></p> <h2 id="_16、请求分页存储管理"><a href="#_16、请求分页存储管理" class="header-anchor">#</a> 16、请求分页存储管理</h2> <ol><li><p>请求分页存储管理与基本分页存储管理的主要区别：</p> <ul><li>在程序执行过程中，当所<strong>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</strong>，然后继续执行</li> <li>若内存空间不够，由<strong>操作系统负责将内存中暂时用不到的信息换出到外存</strong></li></ul></li> <li><p>请求分页管理的方式</p> <ul><li>页表机制</li> <li>缺页中断机构</li> <li>地址变换机构</li></ul></li> <li><p>页表机制</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220515160709826.png" alt="image-20220515160709826"></p></li> <li><p>缺页中断机构</p> <ul><li>在请求分页系统中，每当要访问的<strong>页面不在内存</strong>时，便产生一个<strong>缺页中断</strong>，然后由操作系统的<strong>缺页中断处理程序处理中断</strong></li> <li>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，<strong>调页完成之后再将其唤醒</strong>，放回就绪队列</li> <li>如果内存中<strong>有空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项</li> <li>如果内存中<strong>没有空闲块</strong>，则<strong>由页面置换算法选择一个页面淘汰</strong>，若该页面在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存</li></ul> <p>​       <strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此<strong>属于内中断</strong>。一条指令在执行期间，可能产生多次缺页中断(比如copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p></li> <li><p>地址变换机构</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220515204309592.png" alt="image-20220515204309592"></p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220515204850109.png" alt="image-20220515204850109"></p></li></ol> <p><img src="C:%5CUsers%5CAIERXUAN%5CDesktop%5Cpicture%5Cimage-20220515205239512.png" alt="image-20220515205239512"></p> <h2 id="_17、页面置换算法"><a href="#_17、页面置换算法" class="header-anchor">#</a> 17、页面置换算法</h2> <p>算法种类：最佳置换算法(OPT)，先进先出置换算法(FIFO)，最近最久未使用置换算法(LRU)，时钟置换算法(CLOCK)，改进型的时钟置换算法</p> <p>页面的换入、换出需要磁盘的I/O，会有较大的开销，因此页面置换算法应该<strong>追求更少的缺页率。</strong></p> <ol><li><p>最佳置换算法(OPT)</p> <ul><li>每次选择<strong>淘汰的页面将是以后永不使用</strong>，<strong>或者在最长时间内不再被访问的页面</strong>。追求的是最低的缺页率，但在实际过程中，只有在进程执行的过程中才能知道接下来会访问的是哪个页面，操作系统无法提前预判页面访问序列。<strong>因此最佳置换算法是无法实现的</strong></li> <li><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521130218677.png" alt="image-20220521130218677"></li> <li>上图缺页中断发生了9次，页面置换发生了6次(注意：缺页时未必发生页面置换，若还有可用的空闲内存块，就不用进行页面置换)</li> <li>缺页率 = 9 / 20 = 45%</li></ul></li> <li><p>先进先出置换算法(FIFO)</p> <ul><li>每次选择淘汰的页面是<strong>最早进入内存的页面</strong></li> <li>实现方法：将调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</li> <li>先进入的页面在之后也有可能经常的访问到，所以算法性能较差</li> <li><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521131041972.png" alt="image-20220521131041972"></li> <li>缺页9次。当分配四个内存块的时候，缺页发生10次，分配三个内存块时，缺页发生9次</li> <li><strong>Belady异常</strong>---当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</li></ul></li> <li><p>最近最久未使用置换算法(LRU)</p> <ul><li><p><strong>每次淘汰的页面是最近最久未使用的页面</strong></p></li> <li><p><strong>页表项中的访问字段记录页面自上次被访问以来所经历的时间t</strong>，当需要淘汰一个页面时，选择现有页面中t值的最大的，即最近最久未使用的页面</p></li> <li><p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521132954826.png" alt="image-20220521132954826"></p> <p>找最晚出现的淘汰掉</p></li> <li><p>算法的<strong>实现需要专门的硬件支持</strong>，虽然算法性能好，但是<strong>实现困难，开销大</strong></p></li></ul></li> <li><p>时钟置换算法(CLOCK)</p> <ul><li><p>时钟置换算法是一种性能和开销较均衡的算法，又称<strong>CLOCK算法，或最近未使用算法</strong>(NRU)</p></li> <li><p><strong>简单的CLOCK算法实现方法</strong>：为每一个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针<strong>链接成一个循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描所有页面都是1，则将这些页面的访问依次置为0，再进行第二轮扫描(<strong>第二轮扫描一定会有访问位为0的页面</strong>)</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521133823507.png" alt="image-20220521133823507"></p></li> <li><p>改进型时钟置换算法思想：简单的时钟置换算法仅仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过时，才需要写回外存</strong>。因此，<strong>在其他条件都相同时，应该优先淘汰没有修改过的页面</strong>，避免I/O操作。修改为=0，表示页面没有被修改过；修改为=1，表示页面被修改过，用**(访问位，修改位)**的形式表示各页面的状态，比如(1,1)表示一个页面近期被访问过，且被修改过。</p> <ul><li>算法规则：将所有可能被置换的页面排成一个循环队列
<ol><li>第一轮：从当前位置开始扫描到第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位(最近没有访问且没有修改过的页面)</li> <li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0 (最近没访问，但修改过的页面)</li> <li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位(最近访问过，但没有修改过的页面)</li> <li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换(最近访问过，且修改过的页面)</li></ol></li> <li>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，所有淘汰一个页面最多进行四轮扫描</li></ul></li></ul></li></ol> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521141844658.png" alt="image-20220521141844658"></p> <h2 id="_18、页面分配策略"><a href="#_18、页面分配策略" class="header-anchor">#</a> 18、页面分配策略</h2> <ol><li><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合，采用虚拟内存技术的系统中，驻留集大小一般小于进程的总大小</p> <ul><li><p>驻留集太小，会导致缺页频繁，系统要花大量的时间来处理分页，实际用于进程推进的时间很少</p></li> <li><p>驻留集太大，又会导致多道程序并发度下降，资源利用率低</p></li> <li><p>固定分配：操作系统为每一个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，<strong>驻留集大小不变</strong></p></li> <li><p>可变分配：先为进程分配一定数目的物理块，在进程运行期间，可以根据情况做出适当的增加或减少。即，<strong>驻留集大小可变</strong></p></li> <li><p>局部置换：发生缺页时只能选进程自己的物理块进行置换</p></li> <li><p>全局置换：可将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</p></li> <li><table><thead><tr><th></th> <th>局部置换</th> <th>全局置换</th></tr></thead> <tbody><tr><td>固定分配</td> <td>√</td> <td>---</td></tr> <tr><td>可变分配</td> <td>√</td> <td>√</td></tr></tbody></table></li> <li><p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521200544645.png" alt="image-20220521200544645"></p></li></ul></li> <li><p>何时调入页面</p> <ul><li>1、预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更加高效。但如果提前调入的页面大多数都没被访问过，则又是低效的。故这种策略<strong>主要用于进程首次调入</strong>，由程序员指出应该先调入哪些部分(运行前调入)</li> <li>2、请求调页策略：<strong>进程在运行期间发现缺页时才将所缺页面调入内存</strong>。由于这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大(运行时调入)</li></ul></li> <li><p>从何处调入页面</p> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521202834105.png" alt="image-20220521202834105"></p></li> <li><p>抖动(颠簸)现象</p> <p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为<strong>抖动，或颠簸</strong>。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p></li> <li><p>工作集：指在某段时间间隔里，进程实际访问页面的集合</p> <p>驻留集的大小不能小于工作集的大小，否则进程运行过程中将频繁缺页</p></li></ol> <p><img src="https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220521203500688.png" alt="image-20220521203500688"></p></div></section> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/vingkin/Blog/edit/docs/docs/OS/OS2.md" target="_blank" rel="noopener noreferrer">编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/Blog/OS/OS1.html" class="prev">
            操作系统上
          </a></span> <span class="next"><a href="/Blog/OS/OS3.html">
            操作系统下
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_1、死锁的概念" class="sidebar-link reco-side-_1、死锁的概念" data-v-cb1513f6>1、死锁的概念</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_2、死锁的处理策略-预防死锁" class="sidebar-link reco-side-_2、死锁的处理策略-预防死锁" data-v-cb1513f6>2、死锁的处理策略----预防死锁</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_3、死锁的处理策略-避免死锁" class="sidebar-link reco-side-_3、死锁的处理策略-避免死锁" data-v-cb1513f6>3、死锁的处理策略----避免死锁</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_4、死锁的处理策略-检测和解除" class="sidebar-link reco-side-_4、死锁的处理策略-检测和解除" data-v-cb1513f6>4、死锁的处理策略----检测和解除</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_5、内存的基础知识" class="sidebar-link reco-side-_5、内存的基础知识" data-v-cb1513f6>5、内存的基础知识</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_6、内存管理的概念" class="sidebar-link reco-side-_6、内存管理的概念" data-v-cb1513f6>6、内存管理的概念</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_7、内存空间的扩充-覆盖与交换" class="sidebar-link reco-side-_7、内存空间的扩充-覆盖与交换" data-v-cb1513f6>7、内存空间的扩充-----覆盖与交换</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_8、内存空间的分配-连续分配管理方式" class="sidebar-link reco-side-_8、内存空间的分配-连续分配管理方式" data-v-cb1513f6>8、内存空间的分配-----连续分配管理方式</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_9、动态分区分配算法" class="sidebar-link reco-side-_9、动态分区分配算法" data-v-cb1513f6>9、动态分区分配算法</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_10、基本分页存储管理的基本概念" class="sidebar-link reco-side-_10、基本分页存储管理的基本概念" data-v-cb1513f6>10、基本分页存储管理的基本概念</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_11、基地址变换机构" class="sidebar-link reco-side-_11、基地址变换机构" data-v-cb1513f6>11、基地址变换机构</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_12、两级页表" class="sidebar-link reco-side-_12、两级页表" data-v-cb1513f6>12、两级页表</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_13、基本分段存储管理方式" class="sidebar-link reco-side-_13、基本分段存储管理方式" data-v-cb1513f6>13、基本分段存储管理方式</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_14、段页式管理方式" class="sidebar-link reco-side-_14、段页式管理方式" data-v-cb1513f6>14、段页式管理方式</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_15、虚拟内存的概念" class="sidebar-link reco-side-_15、虚拟内存的概念" data-v-cb1513f6>15、虚拟内存的概念</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_16、请求分页存储管理" class="sidebar-link reco-side-_16、请求分页存储管理" data-v-cb1513f6>16、请求分页存储管理</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_17、页面置换算法" class="sidebar-link reco-side-_17、页面置换算法" data-v-cb1513f6>17、页面置换算法</a></li><li class="level-2" data-v-cb1513f6><a href="/Blog/OS/OS2.html#_18、页面分配策略" class="sidebar-link reco-side-_18、页面分配策略" data-v-cb1513f6>18、页面分配策略</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/Blog/assets/js/app.4417eb82.js" defer></script><script src="/Blog/assets/js/3.2daec6eb.js" defer></script><script src="/Blog/assets/js/1.3441dec7.js" defer></script><script src="/Blog/assets/js/11.385157e5.js" defer></script>
  </body>
</html>
